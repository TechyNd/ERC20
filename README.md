# ERC20
Classtask
pragma solidity ^0.8.0; interface IERC20{ function totalSupply() external view returns(uint); function balanceOf(address account) external view returns(uint); function transfer(address recipient, uint amount) external returns(bool); function allowance(address owner, address spender) external view returns(uint); function approve(address spender, uint amount) external returns(bool); function transferFrom(address sender, address recipient, uint amount) external returns(bool); event Transfer(address indexed from, address indexed to, uint amount); event Approval(address indexed owner, address indexed spender, uint amount); }
pragma solidity ^0.8.0; import "./ierc.sol"; contract ERC20 is IERC20{ uint public override totalSupply; mapping(address => uint) public override balanceOf; mapping(address => mapping(address => uint)) public override allowance; string public name ="Ndiana Token"; string public symbol ="NTK"; uint public decimals = 18; function transfer(address recipient, uint amount) external override returns(bool){ balanceOf[msg.sender] -= amount; //method 1 is deducting the amount from sender's balance balanceOf[recipient] += amount; //method 2 is adding amount to recipient's balance emit Transfer(msg.sender, recipient, amount); return true; } function approve(address spender, uint amount) external override returns(bool){ allowance[msg.sender][spender] = amount; emit Approval(msg.sender, spender, amount); return true; } function transferFrom(address sender, address recipient, uint amount) external override returns(bool){ allowance[sender][msg.sender] -= amount; balanceOf[sender] -= amount; balanceOf[recipient] += amount; emit Transfer(sender, recipient, amount); return true; } }
